#!/usr/bin/env ruby

# Before doing anything else, need to
# force bundler to load up so we
# can require gems from the Gemfile
#
require "pathname"
ENV["BUNDLE_GEMFILE"] ||= File.expand_path("../../Gemfile",
                                           Pathname.new(__FILE__).realpath)
bundle_binstub = File.expand_path("../bundle", __FILE__)

if File.file?(bundle_binstub)
  if File.read(bundle_binstub, 300) =~ /This file was generated by Bundler/
    load(bundle_binstub)
  else
    abort("Your `bin/bundle` was not generated by Bundler, so this binstub cannot run.
Replace `bin/bundle` by running `bundle binstubs bundler --force`, then run this command again.")
  end
end

require "bundler/setup"

# Add the local lib

$LOAD_PATH.unshift (Pathname(__dir__).parent + 'lib').to_s
$LOAD_PATH.unshift (Pathname(__dir__).parent + 'indexer').to_s

# Now we can actually load stuff

require 'hanami/cli'
require "services"
require 'med_installer'

# Set this up as a CLI
module MedInstaller
  class CLI
    extend Hanami::CLI::Registry
  end
end


# Let's simplify things:

# Unzip and convert new data into a build directory 
require "med_installer/prepare"
MedInstaller::CLI.register 'newdata prepare', MedInstaller::Prepare

# Or do them one at a time
MedInstaller::CLI.register "newdata extract", MedInstaller::Extract
MedInstaller::CLI.register "newdata convert", MedInstaller::Convert

# Actually index
# Index things into solr
# MedInstaller::CLI.register 'extract', MedInstaller::Extract, aliases: ['unzip']
# MedInstaller::CLI.register 'convert', MedInstaller::Convert, aliases: ['json']
# MedInstaller::CLI.register 'index copy_from_build', MedInstaller::CopyFromBuild
# MedInstaller::CLI.register 'index entries', MedInstaller::Index::Entries
# MedInstaller::CLI.register 'index bib', MedInstaller::Index::Bib
# MedInstaller::CLI.register 'index full', MedInstaller::Index::Full, aliases: ['all']
#
# # Create the hyp_to_bibid.json mapping and put it in Dromedary.config.data_dir
MedInstaller::CLI.register 'index hyp_to_bibid', MedInstaller::Index::HypToBibID, aliases: ['mapping']
#
# # Reload the solr config (necessary after a change to the solr config has been pushed)
# MedInstaller::CLI.register 'solr reload', MedInstaller::Solr::Reload, aliases: ['bounce']
#
# # Rebuild the indexing underlying autocomplete (should never be necessary, but...)
# MedInstaller::CLI.register 'solr rebuild_suggesters', MedInstaller::Solr::RebuildSuggesters
#
#
# # Remote deployment and execution
# #
# MedInstaller::CLI.register 'deploy', MedInstaller::Remote::Deploy
#
# # Restart removed from moku???
# #MedInstaller::CLI.register 'restart', MedInstaller::Remote::Restart
#
# MedInstaller::CLI.register 'remote', MedInstaller::Remote::Dromedary
# MedInstaller::CLI.register 'remote-exec', MedInstaller::Remote::Exec
#
#
# # Maintenance mode
# MedInstaller::CLI.register 'maintenance_mode on', MedInstaller::Control::MaintenanceModeOn
# MedInstaller::CLI.register 'maintenance_mode off', MedInstaller::Control::MaintenanceModeOff
#
# # Solr utilities for your development environment.
# MedInstaller::CLI.register 'solr install', MedInstaller::Solr::Install
# #MedInstaller::CLI.register 'solr link', MedInstaller::Solr::Link # TODO: Fix this for solr libs
# MedInstaller::CLI.register 'solr start', MedInstaller::Solr::Start, aliases: ['restart']
# MedInstaller::CLI.register 'solr stop', MedInstaller::Solr::Stop
# MedInstaller::CLI.register 'solr empty', MedInstaller::Solr::Empty, aliases: ['clear']
# MedInstaller::CLI.register 'solr commit', MedInstaller::Solr::Commit
# MedInstaller::CLI.register 'solr optimize', MedInstaller::Solr::Optimize
# MedInstaller::CLI.register 'solr up', MedInstaller::Solr::Up, aliases: ['up?']
# MedInstaller::CLI.register 'solr shell', MedInstaller::Solr::Shell




# MedInstaller::CLI.register 'newdata index', MedInstaller::IndexNewData
# MedInstaller::CLI.register 'ping_prometheus', MedInstaller::PingPrometheus
# MedInstaller::CLI.register 'extract_convert_index', MedInstaller::ExtractConvertIndex, aliases: ['load_new_data']

Hanami::CLI.new(MedInstaller::CLI).call

