<?xml version="1.0" encoding="UTF-8" ?>


<!-- Load up stuff we keep in external files -->
<!DOCTYPE config [
        <!ENTITY headword_only_search   SYSTEM "solrconfig_med/entry_searches/headword_only_search.xml">
        <!ENTITY headword_and_forms_search   SYSTEM "solrconfig_med/entry_searches/headword_and_forms_search.xml">
        <!ENTITY everything_search   SYSTEM "solrconfig_med/entry_searches/everything_search.xml">
        <!ENTITY citation_search SYSTEM "solrconfig_med/entry_searches/citation_search.xml">
        <!ENTITY highlighting_defaults   SYSTEM "solrconfig_med/entry_searches/highlighting.xml">

        <!ENTITY headword_only_suggester SYSTEM "solrconfig_med/suggesters/headword_only_suggester.xml">
        <!ENTITY headword_and_forms_suggester SYSTEM "solrconfig_med/suggesters/headword_and_forms_suggester.xml">
        <!ENTITY oed_suggester SYSTEM "solrconfig_med/suggesters/oed_suggester.xml">
        <!ENTITY doe_suggester SYSTEM "solrconfig_med/suggesters/doe_suggester.xml">


        <!ENTITY bib_everything_search SYSTEM "solrconfig_med/bib_searches/everything_search.xml">
        <!ENTITY bib_author_title_search SYSTEM "solrconfig_med/bib_searches/author_title_search.xml">
        <!ENTITY bib_external_references_search SYSTEM "solrconfig_med/bib_searches/external_references_search.xml">
        <!ENTITY bib_lalme_search SYSTEM "solrconfig_med/bib_searches/lalme_search.xml">
        <!ENTITY bib_manuscript_search SYSTEM "solrconfig_med/bib_searches/manuscript_search.xml">
        <!ENTITY bib_stencil_search SYSTEM "solrconfig_med/bib_searches/stencil_search.xml">


        ]>

<config>
  <luceneMatchVersion>6.0.0</luceneMatchVersion>
  <dataDir>${solr.blacklight-core.data.dir:}</dataDir>

  <lib dir="../lib" regex=".*\.jar"/>

  <!--
     Remove the /select handler and set handleSelect to be true so passing
     a qt value will change the requestHandler used.

     -->

  <!-- <requestHandler name="/select" class="solr.SearchHandler"></requestHandler>-->
  <requestDispatcher handleSelect="true">

    <requestParsers enableRemoteStreaming="true"
                    multipartUploadLimitInKB="2048000"
                    formdataUploadLimitInKB="2048"
                    addHttpRequestToContext="false"/>

    <httpCaching never304="true"/>

  </requestDispatcher>


  <!-- generic handler -->
  <requestHandler name="/search" class="solr.SearchHandler" default="true">
    <lst name="defaults">
      <str name="echoParams">all</str>
      <str name="wt">json</str>
      <str name="indent">true</str>
      <str name="fl">*</str>
      <str name="defType">edismax</str>


      <!--Load up stuff from the external files-->
      &headword_and_forms_search;
      &headword_only_search;
      &everything_search;
      &highlighting_defaults;
      &citation_search;



      <!--Some sane defaults-->
      <str name="facet.mincount">1</str>
      <str name="qf">
        official_headword_exactish^500
        official_headword^100
        headword_exactish^50
        headword^10
        orth^1
      </str>

    </lst>

    <!-- Always restrict to entry documents -->
    <lst name="appends">
      <str name="fq">type:entry</str>
    </lst>
  </requestHandler>



  <requestHandler name="/document" class="solr.SearchHandler">
    <lst name="defaults">
      <str name="echoParams">all</str>
      <str name="fl">*</str>
      <str name="rows">1</str>
      <str name="q">{!raw f=id v=$id}</str>
    </lst>

    <!-- Always restrict to entry documents -->
    <lst name="appends">
      <str name="fq">type:entry</str>
    </lst>
  </requestHandler>


  <!-- ################################################
       #             BIB SEARCH                       #
       ################################################  -->

  <!-- Bib single-document handler -->
  <requestHandler name="/bibdoc" class="solr.SearchHandler">
    <lst name="defaults">
      <str name="echoParams">all</str>
      <str name="fl">*</str>
      <str name="rows">1</str>
      <str name="q">{!raw f=id v=$id}</str>
    </lst>

    <!-- Always restrict to bib documents -->
    <lst name="appends">
      <str name="fq">type:bib</str>
    </lst>
  </requestHandler>

  <!-- Bib search handler -->
  <requestHandler name="/bibsearch" class="solr.SearchHandler" default="true">

      <lst name="defaults">
        <str name="echoParams">all</str>
        <str name="wt">json</str>
        <str name="indent">true</str>
        <str name="fl">*</str>
        <str name="defType">edismax</str>
        <str name="facet.mincount">1</str>
        <str name="qf">keyword</str>
    </lst>

    &bib_everything_search;
    &bib_author_title_search;
    &bib_external_references_search;
    &bib_lalme_search;
    &bib_manuscript_search;
    &bib_stencil_search;


    <!-- Always restrict to bib documents -->
    <lst name="appends">
      <str name="fq">type:bib</str>
    </lst>
  </requestHandler>


  <!--## Suggest stuff ##-->

  <!--Mount suggester for headwords and forms at /headword_and_forms_suggester-->

  &headword_and_forms_suggester;

  <!--Mount headword-only suggester at /headword_only_suggester-->

  &headword_only_suggester;

  <!--Mount Oxford English Dictionary modern english suggester at /oed_suggester-->

  &oed_suggester;

<!-- Ditto for the Dictionary of Old English at /doe_suggester-->
  &doe_suggester;



  <!-- A SAMPLE SUGGEST SETUP

    I found it hard to figure out which bits of the suggest setup
    did what. Here's what I got

  <searchComponent name="XXX" class="solr.SuggestComponent">
    <lst name="suggester">
      <str name="name">ZZZ</str>
      <str name="lookupImpl">FSTLookupFactory</str>
      <str name="suggestAnalyzerFieldType">me_text</str>
      <str name="buildOnCommit">true</str>
      <str name="field">MYFIELD</str>
      <str name="exactMatchFirst">true</str>
      <str name="buildOnStartup">true</str>
      <str name="minPrefixChars">2</str>
      <str name="dictionaryImpl">DocumentDictionaryFactory</str>
    </lst>
  </searchComponent>

  <requestHandler name="/WHATEVER_PATH_YOU_WANT" class="solr.SearchHandler"
                  startup="lazy">
    <lst name="defaults">
      <str name="suggest">true</str>
      <str name="suggest.count">15</str>
      <str name="suggest.dictionary">ZZZ</str>
    </lst>
    <arr name="components">
      <str>XXX</str>
    </arr>
  </requestHandler>

  where:
    XXX is the name of the searchComponent
    ZZZ is the name of the individual *suggester*.

    XXX and ZZZ can be the same string, if you like.

    XXX is used ONLY IN THE SOLRCONFIG, to name the suggestComponent
    and then referenced as a component in the requestHander

    ZZZ is used in two places:
      * It's the name of the dictionary used when configuring the
        requestHandler
      * It's the key in the hash returned by solr when you look for
        results.

    So in this case, a solr search on the three character string "din"
    with suggestions on would return a hash of the form:

    response:
      responseHeader:
        status: 0
        QTime: 0
      suggest:
        ZZZ
          din:
            numFound: 15
            suggestions:
              -
                term: dine
                weight: 1
                payload:
              -
                term: ding
                weight: 1
                payload:
      ...etc.




  -->


  <!--<initParams path="/update/**,/query,/select,/tvrh,/elevate,/spell">-->
  <!--<lst name="defaults">-->
  <!--<str name="df">text</str>-->
  <!--</lst>-->
  <!--</initParams>-->

  <!-- Field Analysis Request Handler

       RequestHandler that provides much the same functionality as
       analysis.jsp. Provides the ability to specify multiple field
       types and field names in the same request and outputs
       index-time and query-time analysis for each of them.

       Request parameters are:
       analysis.fieldname - field name whose analyzers are to be used

       analysis.fieldtype - field type whose analyzers are to be used
       analysis.fieldvalue - text for index-time analysis
       q (or analysis.q) - text for query time analysis
       analysis.showmatch (true|false) - When set to true and when
           query analysis is performed, the produced tokens of the
           field value analysis will be marked as "matched" for every
           token that is produces by the query analysis
   -->
  <requestHandler name="/analysis/field"
                  startup="lazy"
                  class="solr.FieldAnalysisRequestHandler"/>


  <!-- Document Analysis Handler

       http://wiki.apache.org/solr/AnalysisRequestHandler

       An analysis handler that provides a breakdown of the analysis
       process of provided documents. This handler expects a (single)
       content stream with the following format:

       <docs>
         <doc>
           <field name="id">1</field>
           <field name="name">The Name</field>
           <field name="text">The Text Value</field>
         </doc>
         <doc>...</doc>
         <doc>...</doc>
         ...
       </docs>

    Note: Each document must contain a field which serves as the
    unique key. This key is used in the returned response to associate
    an analysis breakdown to the analyzed document.

    Like the FieldAnalysisRequestHandler, this handler also supports
    query analysis by sending either an "analysis.query" or "q"
    request parameter that holds the query text to be analyzed. It
    also supports the "analysis.showmatch" parameter which when set to
    true, all field tokens that match the query tokens will be marked
    as a "match".
  -->
  <requestHandler name="/analysis/document"
                  class="solr.DocumentAnalysisRequestHandler"
                  startup="lazy"/>

  <!-- Echo the request contents back to the client -->
  <requestHandler name="/debug/dump" class="solr.DumpRequestHandler">
    <lst name="defaults">
      <str name="echoParams">explicit</str>
      <str name="echoHandler">true</str>
    </lst>
  </requestHandler>


  <!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

       Caching, locking, and other low-level crap
       that is generally less messed-with than
       the above stuff.

  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -->


  <!-- The DirectoryFactory to use for indexes.
       One can force a particular implementation via solr.MMapDirectoryFactory,
       solr.NIOFSDirectoryFactory, or solr.SimpleFSDirectoryFactory.

       solr.RAMDirectoryFactory is memory based, not
       persistent, and doesn't work with replication.
    -->
  <directoryFactory name="DirectoryFactory"
                    class="${solr.directoryFactory:solr.NRTCachingDirectoryFactory}">
  </directoryFactory>

  <!-- Use the classic schema.xml instead of a managed schema -->
  <schemaFactory class="ClassicIndexSchemaFactory"/>
  <codecFactory class="solr.SchemaCodecFactory"/>

  <indexConfig>
    <lockType>${solr.lock.type:native}</lockType>
    <infoStream>true</infoStream>
  </indexConfig>

  <jmx/>


  <!-- Dedup some fields -->
  <processor class="solr.UniqFieldsUpdateProcessorFactory">
    <str name="fieldRegex">.*_uniq</str>
  </processor>

  <!-- The default high-performance update handler -->
  <updateHandler class="solr.DirectUpdateHandler2">
    <!--<updateLog>-->
      <!--<str name="dir">${solr.ulog.dir:}</str>-->
      <!--<int name="numVersionBuckets">${solr.ulog.numVersionBuckets:65536}-->
      <!--</int>-->
    <!--</updateLog>-->

    <autoCommit>
      <maxTime>15000</maxTime>
      <openSearcher>false</openSearcher>
    </autoCommit>

  </updateHandler>


  <!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
       Query section - these settings control query time things like caches
       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
  <query>

    <maxBooleanClauses>1024</maxBooleanClauses>


    <filterCache class="solr.FastLRUCache"
                 size="512"
                 initialSize="512"
                 autowarmCount="0"/>

    <queryResultCache class="solr.LRUCache"
                      size="512"
                      initialSize="512"
                      autowarmCount="0"/>

    <documentCache class="solr.LRUCache"
                   size="512"
                   initialSize="512"
                   autowarmCount="0"/>

    <!-- custom cache currently used by block join -->
    <!--    <cache name="perSegFilter"
      class="solr.search.LRUCache"
      size="10"
      initialSize="0"
      autowarmCount="10"
      regenerator="solr.NoOpRegenerator" />
    -->


    <enableLazyFieldLoading>true</enableLazyFieldLoading>
    <queryResultWindowSize>100</queryResultWindowSize>
    <queryResultMaxDocsCached>200</queryResultMaxDocsCached>

    <useColdSearcher>false</useColdSearcher>
    <maxWarmingSearchers>2</maxWarmingSearchers>

  </query>


  <!-- Search Components

       Search components are registered to SolrCore and used by 
       instances of SearchHandler (which can access them by name)
       
       By default, the following components are available:
       
       <searchComponent name="query"     class="solr.QueryComponent" />
       <searchComponent name="facet"     class="solr.FacetComponent" />
       <searchComponent name="mlt"       class="solr.MoreLikeThisComponent" />
       <searchComponent name="highlight" class="solr.HighlightComponent" />
       <searchComponent name="stats"     class="solr.StatsComponent" />
       <searchComponent name="debug"     class="solr.DebugComponent" />
       
     -->

  <!-- Terms Component

       http://wiki.apache.org/solr/TermsComponent

       A component to return terms and document frequency of those
       terms
    -->
  <searchComponent name="terms" class="solr.TermsComponent"/>

  <!-- A request handler for demonstrating the terms component -->
  <requestHandler name="/terms" class="solr.SearchHandler" startup="lazy">
    <lst name="defaults">
      <bool name="terms">true</bool>
      <bool name="distrib">false</bool>
    </lst>
    <arr name="components">
      <str>terms</str>
    </arr>
  </requestHandler>

</config>
